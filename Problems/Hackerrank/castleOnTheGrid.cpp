/*********************************************************************************************/
/* Problem: Castle on the grid (HR) ********/
/*********************************************************************************************/
/*
--Problem statement:
  You are given a square grid with some cells open (.) and some blocked (X). Your playing piece
  can move along any row or column until it reaches the edge of the grid or a blocked cell.
  Given a grid, a start and a goal, determine the minimum number of moves to get to the goal.
  Example:
    grid = ['...','.X.','...']
    startX = 0
    startY = 0
    goalX = 1
    goalY = 2
    The starting position (startX, startY) = (0,0) so start in the top left corner. The goal is
    (goalX, goalY) = (1,2). The path is (0,0) -> (0,2) -> (1,2). It takes 2 moves to reach the
    goal.

--Time complexity: O(n^2), since we are building the matrix from the grid vector

--Space complexity: O(n^2), due to the matrices gridMat and distance

*/
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <utility>
#include <limits.h>

// --------------- HELPERS: FORWARD DECLARATIONS -----------------:

void buildAdjMatrix(std::vector<std::string> &gridVec, std::vector<std::vector<char>> &gridMat, const int &r, const int &c);

// --------------------------- SOLUTION --------------------------:
int minimumMoves(std::vector<std::string> grid, int src_X, int src_Y, int end_X, int end_Y)
{
  // check if source and destination are not the same position:
  if ((src_X == end_X) && (src_Y == end_Y))
  {
    return 0;
  }
  // number of rows and columns in the grid:
  const int ROWS = grid.size();
  const int COLS = grid.at(0).size();
  // queues for storing elements coordinates (row,col):
  std::queue<std::pair<int, int>> q;
  // add source coordinates to the queue:
  q.push(std::make_pair(src_X, src_Y));
  // build the 2D grid:
  std::vector<std::vector<char>> gridMatrix(ROWS, std::vector<char>(COLS, ' '));
  buildAdjMatrix(grid, gridMatrix, ROWS, COLS);
  // build a 2D matrix for keeping track of the distances:
  std::vector<std::vector<int>> distance(ROWS, std::vector<int>(COLS, INT_MAX));
  // boolean to indicate if we arrived at the destination:
  bool arrivedAtGoal{false};
  // declare a vector to store the neighbours as we explore the grid:
  std::vector<std::pair<int, int>> neighbours;
  // variable to keep track of the moves:
  int moves_count{0};
  // the distance from the source to itself is zero:
  distance.at(src_X).at(src_Y) = 0;
  // iterate while the queue is not empty:
  while (!q.empty())
  {
    // get the current node's coordinates:
    int curr_row = q.front().first;
    int curr_col = q.front().second;
    // pop current node from the queue since it'll be explored now and to avoid
    // not so nice infinite loop since the will never be empty:
    q.pop();
    // we count the moves by keeping track of the distance from the source, if no
    // turns are taken, i.e. the current node is on the same line/column, the
    // distance does not get updated:
    moves_count = distance.at(curr_row).at(curr_col);
    // if we got to the goal, set the boolean and get out of the loop:
    if ((curr_row == end_X) && (curr_col == end_Y))
    {
      arrivedAtGoal = true;
      break;
    }
    // empty the neighbours' vector to get rid of the neighbours already processed:
    neighbours.clear();

    int new_row, new_col;
    // go up:
    new_row = curr_row - 1;
    while (new_row > -1 && gridMatrix.at(new_row).at(curr_col) != 'X')
    {
      neighbours.push_back(std::make_pair(new_row, curr_col));
      new_row--;
    }
    // go down:
    new_row = curr_row + 1;
    while (new_row < ROWS && gridMatrix.at(new_row).at(curr_col) != 'X')
    {
      neighbours.push_back(std::make_pair(new_row, curr_col));
      new_row++;
    }
    // go left:
    new_col = curr_col - 1;
    while (new_col > -1 && gridMatrix.at(curr_row).at(new_col) != 'X')
    {
      neighbours.push_back(std::make_pair(curr_row, new_col));
      new_col--;
    }
    // go right:
    new_col = curr_col + 1;
    while (new_col < COLS && gridMatrix.at(curr_row).at(new_col) != 'X')
    {
      neighbours.push_back(std::make_pair(curr_row, new_col));
      new_col++;
    }
    // update distances if applicable, i.e. if we got a turn:
    for (auto &next : neighbours)
    {
      int r = next.first;
      int c = next.second;

      if (moves_count + 1 < distance.at(r).at(c))
      {
        distance.at(r).at(c) = moves_count + 1;
        q.push(std::make_pair(r, c));
      }
    }
  }
  if (arrivedAtGoal)
  {
    return moves_count;
  }
  return -1;
}

// ----------------------- DRIVER CODE ---------------------------:
int main()
{
  std::vector<std::string> grid{"...", ".X.", "..."};
  int sx{0}, sy{0}, gx{1}, gy{2};

  std::cout << "minimum moves: " << minimumMoves(grid, sx, sy, gx, gy) << "\n";

  grid = {".X.", ".X.", "..."};
  sx = 0;
  sy = 0;
  gx = 0;
  gy = 2;

  std::cout << "minimum moves: " << minimumMoves(grid, sx, sy, gx, gy) << "\n";

  grid = {
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "....................................................................................................",
      "...................................................................................................."};
  sx = 0;
  sy = 0;
  gx = 99;
  gy = 99;

  std::cout << "minimum moves: " << minimumMoves(grid, sx, sy, gx, gy) << "\n";

  return 0;
}
// ---------------------------------------------------------------:

// -------------------- HELPERS: DEFINITIONS ---------------------:

/**
 * @brief buildMatrix: processes the input vector and lays its
 * data on a adjacency matrix format/grid.
 *
 * @param gridVec
 * @param gridMat
 */
void buildAdjMatrix(std::vector<std::string> &gridVec, std::vector<std::vector<char>> &gridMat, const int &r, const int &c)
{
  for (int i{0}; i < r; i++)
  {
    for (int j{0}; j < c; j++)
    {
      gridMat.at(i).at(j) = gridVec.at(i).at(j);
    }
  }
}
